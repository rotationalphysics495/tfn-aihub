/**
 * ElevenLabs Client (Story 8.1)
 *
 * Frontend client for audio streaming from ElevenLabs TTS.
 * Handles audio playback, pause/resume, and event callbacks.
 *
 * AC#1: TTS Stream URL Generation - Plays audio from generated URLs
 * AC#3: Section Pause Points - Supports pause between sections
 *
 * References:
 * - [Source: architecture/voice-briefing.md#Voice Integration Architecture]
 * - [Source: prd/prd-functional-requirements.md#FR13]
 */

export type AudioEventType =
  | 'playing'
  | 'paused'
  | 'ended'
  | 'error'
  | 'timeupdate'
  | 'canplay'
  | 'waiting';

export interface AudioEventHandler {
  onComplete?: () => void;
  onError?: (error: Error) => void;
  onTimeUpdate?: (currentTime: number, duration: number) => void;
  onCanPlay?: () => void;
  onWaiting?: () => void;
  onPlaying?: () => void;
  onPaused?: () => void;
}

export interface PlaybackState {
  isPlaying: boolean;
  isPaused: boolean;
  isLoading: boolean;
  currentTime: number;
  duration: number;
  volume: number;
  isMuted: boolean;
  error: Error | null;
}

/**
 * ElevenLabs audio streaming client.
 *
 * Story 8.1 Implementation:
 * - AC#1: Plays audio from streaming URLs generated by backend
 * - AC#3: Emits onComplete for pause point handling
 *
 * Usage:
 * ```typescript
 * const client = new ElevenLabsClient();
 * client.onComplete = () => console.log('Playback complete');
 * await client.playStream('/api/voice/tts/stream?...');
 * ```
 */
export class ElevenLabsClient {
  private audio: HTMLAudioElement | null = null;
  private eventHandlers: AudioEventHandler = {};
  private _state: PlaybackState = {
    isPlaying: false,
    isPaused: false,
    isLoading: false,
    currentTime: 0,
    duration: 0,
    volume: 1.0,
    isMuted: false,
    error: null,
  };

  constructor(handlers?: AudioEventHandler) {
    if (handlers) {
      this.eventHandlers = handlers;
    }
  }

  /**
   * Get current playback state.
   */
  get state(): PlaybackState {
    return { ...this._state };
  }

  /**
   * Set event handlers.
   */
  set onComplete(handler: (() => void) | undefined) {
    this.eventHandlers.onComplete = handler;
  }

  set onError(handler: ((error: Error) => void) | undefined) {
    this.eventHandlers.onError = handler;
  }

  set onTimeUpdate(
    handler: ((currentTime: number, duration: number) => void) | undefined
  ) {
    this.eventHandlers.onTimeUpdate = handler;
  }

  set onCanPlay(handler: (() => void) | undefined) {
    this.eventHandlers.onCanPlay = handler;
  }

  set onWaiting(handler: (() => void) | undefined) {
    this.eventHandlers.onWaiting = handler;
  }

  set onPlaying(handler: (() => void) | undefined) {
    this.eventHandlers.onPlaying = handler;
  }

  set onPaused(handler: (() => void) | undefined) {
    this.eventHandlers.onPaused = handler;
  }

  /**
   * Play audio from a streaming URL.
   *
   * AC#1: Streams audio from the backend TTS endpoint.
   * Target: Audio playback within 2 seconds of text generation (NFR9).
   *
   * @param url - Streaming audio URL from backend
   * @returns Promise that resolves when playback starts, rejects on error
   */
  async playStream(url: string): Promise<void> {
    // Clean up any existing audio
    this.stop();

    return new Promise((resolve, reject) => {
      try {
        // Create new audio element
        this.audio = new Audio();
        this._state.isLoading = true;
        this._state.error = null;

        // Set up event listeners
        this.setupEventListeners(resolve, reject);

        // Start loading
        this.audio.src = url;
        this.audio.load();
      } catch (error) {
        this._state.isLoading = false;
        this._state.error =
          error instanceof Error ? error : new Error(String(error));
        reject(this._state.error);
      }
    });
  }

  /**
   * Set up audio event listeners.
   */
  private setupEventListeners(
    resolve: () => void,
    reject: (error: Error) => void
  ): void {
    if (!this.audio) return;

    // Can play - audio is ready
    this.audio.addEventListener('canplay', () => {
      this._state.isLoading = false;
      this._state.duration = this.audio?.duration || 0;
      this.eventHandlers.onCanPlay?.();

      // Auto-play when ready
      this.audio
        ?.play()
        .then(() => {
          this._state.isPlaying = true;
          this._state.isPaused = false;
          this.eventHandlers.onPlaying?.();
          resolve();
        })
        .catch((error) => {
          // Handle autoplay restrictions
          this._state.error = error;
          this.eventHandlers.onError?.(error);
          reject(error);
        });
    });

    // Time update - track progress
    this.audio.addEventListener('timeupdate', () => {
      if (this.audio) {
        this._state.currentTime = this.audio.currentTime;
        this._state.duration = this.audio.duration || 0;
        this.eventHandlers.onTimeUpdate?.(
          this._state.currentTime,
          this._state.duration
        );
      }
    });

    // Ended - playback complete (AC#3: pause point)
    this.audio.addEventListener('ended', () => {
      this._state.isPlaying = false;
      this._state.isPaused = false;
      this.eventHandlers.onComplete?.();
    });

    // Error handling
    this.audio.addEventListener('error', () => {
      const error = new Error(
        this.audio?.error?.message || 'Audio playback error'
      );
      this._state.isLoading = false;
      this._state.isPlaying = false;
      this._state.error = error;
      this.eventHandlers.onError?.(error);
      reject(error);
    });

    // Paused
    this.audio.addEventListener('pause', () => {
      this._state.isPlaying = false;
      this._state.isPaused = true;
      this.eventHandlers.onPaused?.();
    });

    // Playing (resumed)
    this.audio.addEventListener('playing', () => {
      this._state.isPlaying = true;
      this._state.isPaused = false;
      this._state.isLoading = false;
      this.eventHandlers.onPlaying?.();
    });

    // Waiting (buffering)
    this.audio.addEventListener('waiting', () => {
      this._state.isLoading = true;
      this.eventHandlers.onWaiting?.();
    });
  }

  /**
   * Pause playback.
   */
  pause(): void {
    if (this.audio && this._state.isPlaying) {
      this.audio.pause();
    }
  }

  /**
   * Resume playback.
   */
  resume(): void {
    if (this.audio && this._state.isPaused) {
      this.audio.play().catch((error) => {
        this._state.error = error;
        this.eventHandlers.onError?.(error);
      });
    }
  }

  /**
   * Toggle play/pause.
   */
  togglePlayPause(): void {
    if (this._state.isPlaying) {
      this.pause();
    } else if (this._state.isPaused) {
      this.resume();
    }
  }

  /**
   * Stop playback and clean up.
   */
  stop(): void {
    if (this.audio) {
      this.audio.pause();
      this.audio.src = '';
      this.audio = null;
    }

    this._state = {
      isPlaying: false,
      isPaused: false,
      isLoading: false,
      currentTime: 0,
      duration: 0,
      volume: this._state.volume,
      isMuted: this._state.isMuted,
      error: null,
    };
  }

  /**
   * Set volume (0-1).
   */
  setVolume(volume: number): void {
    const clampedVolume = Math.max(0, Math.min(1, volume));
    this._state.volume = clampedVolume;

    if (this.audio) {
      this.audio.volume = clampedVolume;
    }
  }

  /**
   * Toggle mute.
   */
  toggleMute(): void {
    this._state.isMuted = !this._state.isMuted;

    if (this.audio) {
      this.audio.muted = this._state.isMuted;
    }
  }

  /**
   * Set muted state.
   */
  setMuted(muted: boolean): void {
    this._state.isMuted = muted;

    if (this.audio) {
      this.audio.muted = muted;
    }
  }

  /**
   * Seek to a specific time.
   */
  seek(time: number): void {
    if (this.audio && this._state.duration > 0) {
      const clampedTime = Math.max(0, Math.min(time, this._state.duration));
      this.audio.currentTime = clampedTime;
      this._state.currentTime = clampedTime;
    }
  }

  /**
   * Get progress as a percentage (0-100).
   */
  getProgress(): number {
    if (this._state.duration === 0) return 0;
    return (this._state.currentTime / this._state.duration) * 100;
  }

  /**
   * Format time as MM:SS.
   */
  static formatTime(seconds: number): string {
    if (!isFinite(seconds) || seconds < 0) return '0:00';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }
}

/**
 * Create a new ElevenLabsClient instance.
 */
export function createElevenLabsClient(
  handlers?: AudioEventHandler
): ElevenLabsClient {
  return new ElevenLabsClient(handlers);
}
